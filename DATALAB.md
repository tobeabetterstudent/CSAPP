# DataLab
* `bitXor`：
    * `or`：` 0|0=0, 0|1=1, 1|0=1, 1|1=1`
    * `and`：`0&0=0, 0&1=0, 1&0=0，1&1=1`，$$A \lor B = \neg(\neg(A \lor B))=\neg(\neg A \land \neg B)$$
    * `xor`：`0^0=0, 0^1=1, 1^0=1, 1^1 = 0`；两个对象`A, B`，`A^B=1`当且仅当`A!=B`，也即有$$A\oplus B = A \neg B \lor \neg AB$$
* `isTmax`：
    * `Tmax`是`0111...1`，要判断一个数字是`Tmax`，要么直接与`Tmax`比较，要么使用`Tmax`的某些性质来判断：
        * 直接与`Tmax`比较，最大的问题就在于如何得到`Tmax`，没有想出不依靠移位就可以得到`Tmax`的办法
        * 使用`Tmax`的性质，`Tmax+1 = Tmin`， `Tmax ^ (-1) = Tmin`，能使这两个条件同时成立的只有`Tmax`，因此是否可以用`x+1 == x^(-1)`来判断呢，首先`x=Tmax`这个等式成立，而`x==-1`时显然也成立，其它数字则不成立，因此只需要排除掉`-1`即可。而`-1`即`111...1`即`~0`，因此满足`!(x+1)^(x^(~0))`的只有`Tmax/-1`，再需要满足`x!=-1，即!!(x^(~0))`，注意：$$x==y 可以用!(x\oplus y)判断，而x!=y，则需要用!!(x\oplus y)$$
* `conditional(int x, int y ,int z)`：
    * `if x return y; else return z;`
    * 因为不能使用`if`，而必须采用位运算，所以必须计算出一个最终返回的值，因此可以利用`&, |`运算可以屏蔽或打开`bit`位的特点，因此必须根据`x`来生成两个掩码`111....1/0000...0`，来表达`x`不为`0`/为`0`的情形，只需要使用`mask=((!!x)<<31>>31`即可，最后，再返回`y&mask|z&(~mask)`
* `isLessOrEqual(int x, int y)`：判断`x<=y`也即是判断`y-x>=0`，比较`2`个数字的大小，如果采用相减的方式会存在溢出的可能，如何处理？对`x,y`异号的情况，可以直接返回，否则再相减
    * 即`!(x&Tmin)^(y&Tmin)? !((y-x)&Tmin):!!(y&Tmin)`，其中`y-x = y+(~x+1)`，再利用上述的`conditional`的方法改写即可。
* `logicalNeg(x)`：即返回`!x`
    * 只有在`x=0`时才返回`1`，如果认为问题等价于判断`x==0`：
    * 如果基于比较的思路判断这一命题，则不可避免的要使用`!`，这显然行不通
    * 不如考察`x`中是否有`1`，可以将`x`不断的折半`|`，即不断的用`x`的高半部分与低半部分相`|`，则最终可以得到`x`中是否有`1`。
    * 注意我们不必每次操作都截断`x`，要想得到`x`的高半部分，只需要右移，而在最后的结果中，我们取最低位即可。
* `howManyBits(x)`：返回表示`x`所需的最少的`bit`数。
    * 所谓的最少，即`x`的`2`进制表示 + `1`位符号位
    * 对正数，找到为`1`的最高位，再加上符号位即可
    * 对负数，由于`11101`与`101`表示的都是同一个数字`-3`，因此所谓的最少即是返回`3`，注意到负数进行符号扩展时，值不变，反过来，截断多余的符号位，值也不变，直到碰到第一个`0`，则不能继续截断，因此对负数要找到为`0`的最高位，再加上符号位即可
    * 如果只考虑正数，如何找到为`1`的最高位？
        * 考虑`x`的高`16bit`是否有`1`，如果有则可以将`x`右移`16`位：则可知`ans`累加`16`；否则对`x`不移位，继续去考虑`x`的低`16bit`是否有`1`
            * 注意到`x`移位与`ans`累加的值总是相同的，因此我们可以将这两种情况统一起来，得到一个表示`x`的高`16bit`是否有`1`的`mask`，将`mask<<4`则可以得到`x`移位与`ans`累加的值：`16/0`
        * 现在`x`只有`16bit`：考虑`x`的高`8bit`，如果有`1`，则可以将`x`右移`8`位：则可知`ans`累加`8`；否则对`x`不移位，继续去考虑`x`的低`8bit`是否有`1`
        * ......
* `float`：
    * 注意`float: [31] [30~23] [22~0]`，分别为`flag, exp, frac`，设`fMask = 1 << 31, eMask = 0xff << 23, rMask = ~(fMask | eMask)`，则可以得到`flag, exp, frac`，**注意它们的bit结构，给exp增加1要使用exp +(1<<23)**
    * 其具体表示的值详细见`Float.md`
* `floatFloat2Int(unsigned uf)`：输入`uf`按照`IEEE754`标准表示一个`float f`，将之进行强制转换`int(f)`：
    * 超出`int`表示界限的应返回`0x8000 0000u`
    * 对`Exp=eMask`的`float`是`inf/Nan`，直接返回`0x8000 0000u`
    * 对`Exp < offset(127)`的`float`，其数字绝对值都小于1，而靠近`0`，可以直接返回`0`
    * 对`Exp`在`[128, eMask)`之间的，就是可以表示为整数的数字了，注意在计算的过程中如果遇到要溢出的就直接返回`0x8000 0000u`
* `floatPower2(int x)`：返回$2.0^x$
    * 对`x>=128`可以直接返回`Inf`，即`0xff<<23`
    * 而对`x`在`[-126, 127]`的可以直接返回`(x+127)<<23`
    * 而对更小的指数，比如$2^{-127},2^{-129}$，则为`denorm`数字
    * 而非规格数能表示的浮点数的`E=-126, exp=000...0; M=0.frac`，所以这时固定`exp=0`，可以将$2^{-127}$表示为`0 00000000 1000...0`，因为在`0.frac`中，小数点右边的值权重依次为$2^{-1}, 2^{-2}...$，因为`frac`最多有`22`位，所以最小可以表示$2^{-22}*2^{-126}=2^{-148}$